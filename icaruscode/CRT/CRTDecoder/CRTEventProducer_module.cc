// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art_root_io/TFileService.h" 
#include "art_root_io/TFileDirectory.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Persistency/Common/PtrMaker.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include <memory>
#include <iostream>
#include <map>
#include <iterator>
#include <algorithm>

// LArSoft
#include "lardataobj/Simulation/AuxDetSimChannel.h"
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/AuxDetGeometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"

// ROOT
#include "TTree.h"
#include "TFile.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TVector3.h"
#include "TGeoManager.h"

#include "icaruscode/CRT/CRTDecoder/CRTPreProcessTree.h"

namespace icarus {
namespace crt {

  class CRTEventProducer : public art::EDProducer {
  public:
 
    explicit CRTEventProducer(fhicl::ParameterSet const & p);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTEventProducer(CRTEventProducer const &) = delete;
    CRTEventProducer(CRTEventProducer &&) = delete;
    CRTEventProducer & operator = (CRTEventProducer const &) = delete; 
    CRTEventProducer & operator = (CRTEventProducer &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;

    // Selected optional functions.
    void beginJob() override;

    void endJob() override;

    void reconfigure(fhicl::ParameterSet const & p);

  private:


   icarus::crt::CRTPreProcessTree* anatree;
   
  }; // class CRTEventProducer

  CRTEventProducer::CRTEventProducer(fhicl::ParameterSet const & p)
  : EDProducer{p}
  // Initialize member data here, if know don't want to reconfigure on the fly
  {
 
   // Call appropriate produces<>() functions here.
    produces< std::vector<float> >();
    
    reconfigure(p);

  } // CRTEventProducer()

  void CRTEventProducer::reconfigure(fhicl::ParameterSet const & p)
  {
    //fCrtModuleLabel = (p.get<art::InputTag> ("CrtModuleLabel"));


  } // CRTEventProducer::reconfigure()

  void CRTEventProducer::beginJob()
  {


  } // CRTEventProducer::beginJob()
 
  void CRTEventProducer::produce(art::Event & event)
  {
    std::unique_ptr< std::vector<float> > vec( new std::vector<float>);

      
    event.put(std::move(vec));


  } // CRTEventProducer::produce()

  void CRTEventProducer::endJob()
  {

  } // CRTEventProducer::endJob()

  DEFINE_ART_MODULE(icarus::crt::CRTEventProducer)

}
} //end namespace
