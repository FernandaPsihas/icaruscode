/////////////////////////////////////////////////////////////////////////////
///// Class:       CRTSimHitProducer
///// Module Type: producer
///// File:        CRTSimHitProducer_module.cc
/////
///// Author:         Thomas Brooks
///// E-mail address: tbrooks@fnal.gov
/////
///// Modified from CRTSimHitProducer by Thomas Warburton.
///////////////////////////////////////////////////////////////////////////////

//// icaruscode includes
#include "icaruscode/CRT/CRTProducts/CRTChannelData.h"
#include "icaruscode/CRT/CRTProducts/CRTData.hh"
#include "icaruscode/CRT/CRTProducts/CRTHit.h"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h" 
#include "art/Framework/Services/Optional/TFileDirectory.h"

#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// C++ includes
#include <memory>
#include <iostream>
#include <map>
#include <iterator>
#include <algorithm>

// LArSoft
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/Simulation/AuxDetSimChannel.h"
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/AuxDetGeometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "larcorealg/Geometry/PlaneGeo.h"
#include "larcorealg/Geometry/WireGeo.h"
#include "lardataobj/RecoBase/OpFlash.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"

// ROOT
#include "TTree.h"
#include "TFile.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TVector3.h"

namespace {
  // Local namespace for local functions

  char MacToType(uint32_t mac);
  uint32_t MacToRegion(uint32_t mac);
  uint32_t MacToAuxDetID(uint32_t mac, uint32_t chan);
  uint32_t ChannelToAuxDetSensitiveID(uint32_t mac, uint32_t chan);

} //namespace local

namespace icarus {
namespace crt {
  
  class CRTSimHitProducer : public art::EDProducer {
  public:

    explicit CRTSimHitProducer(fhicl::ParameterSet const & p);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTSimHitProducer(CRTSimHitProducer const &) = delete;
    CRTSimHitProducer(CRTSimHitProducer &&) = delete;
    CRTSimHitProducer & operator = (CRTSimHitProducer const &) = delete; 
    CRTSimHitProducer & operator = (CRTSimHitProducer &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;

    // Selected optional functions.
    void beginJob() override;

    void endJob() override;

    void reconfigure(fhicl::ParameterSet const & p);

  private:

    // Params from fcl file.......
    art::InputTag fCrtModuleLabel;      ///< name of crt producer
    bool          fVerbose;             ///< print info
    double        fQPed;                ///< Pedestal offset of SiPMs [ADC]
    double        fQSlope;              ///< Pedestal slope of SiPMs [ADC/photon]
    bool          fUseReadoutWindow;    ///< Only reconstruct hits within readout window

    // Other variables shared between different methods.
    geo::GeometryCore const* fGeometryService;                 ///< pointer to Geometry provider
    detinfo::DetectorProperties const* fDetectorProperties;    ///< pointer to detector properties provider
    //art::ServiceHandle<geo::AuxDetGeometry> fAuxDetGeoService;
    //const geo::AuxDetGeometry* fAuxDetGeo;
    //const geo::AuxDetGeometryCore* fAuxDetGeoCore;

  }; // class CRTSimHitProducer 

  CRTSimHitProducer::CRTSimHitProducer(fhicl::ParameterSet const & p)
  // Initialize member data here, if know don't want to reconfigure on the fly
  {
    // Call appropriate produces<>() functions here.
    produces< std::vector<icarus::crt::CRTHit> >();
    
    // Get a pointer to the geometry service provider
    fGeometryService = lar::providerFrom<geo::Geometry>();
    fDetectorProperties = lar::providerFrom<detinfo::DetectorPropertiesService>(); 

    reconfigure(p);

  } // CRTSimHitProducer()

  void CRTSimHitProducer::reconfigure(fhicl::ParameterSet const & p)
  {
    fCrtModuleLabel       = (p.get<art::InputTag> ("CrtModuleLabel")); 
    fVerbose              = (p.get<bool> ("Verbose"));
    fQPed                 = (p.get<double> ("QPed"));
    fQSlope               = (p.get<double> ("QSlope"));
    fUseReadoutWindow     = (p.get<bool> ("UseReadoutWindow"));
  }

  void CRTSimHitProducer::beginJob()
  {
    if(fVerbose){std::cout<<"----------------- CRT Hit Reco Module -------------------"<<std::endl;}
  } // beginJob()

  void CRTSimHitProducer::produce(art::Event & event)
  {

    if(fVerbose){
      std::cout<<"============================================"<<std::endl
               <<"Run = "<<event.run()<<", SubRun = "<<event.subRun()<<", Event = "<<event.id().event()<<std::endl
               <<"============================================"<<std::endl;
    }

    // Detector properties
    //double readoutWindow  = (double)fDetectorProperties->ReadOutWindowSize();
    //double driftTimeTicks = 2.0*(2.*fGeometryService->DetHalfWidth()+3.)/fDetectorProperties->DriftVelocity();

    // Retrieve list of CRT hits
    art::Handle< std::vector<crt::CRTData>> crtListHandle;
    event.getByLabel(fCrtModuleLabel, crtListHandle);

    // Create anab::T0 objects and make association with recob::Track
    std::unique_ptr< std::vector<icarus::crt::CRTHit> > CRTHits ( new std::vector<icarus::crt::CRTHit>);

    uint32_t nHitMiss = 0;

    for (auto const &febdat : (*crtListHandle)) {

      uint32_t mac = febdat.Mac5();
      char type = MacToType(mac);
      uint32_t reg = MacToRegion(mac);
      reg++;
      auto trigpair = febdat.TrigPair();
      auto macPair = febdat.MacPair();

      float t01=0, t02=0;//, t01corr=0, t02corr=0;
      float t11=0, t12=0;//, t11corr=0, t12corr=0;
      float t0=0, t0corr=0, t1=0, t1corr=0;

      //geo::AuxDetGeo& adGeo;
      //geo::AuxDetSensitiveGeo &adsGeo1, &adsGeo2;
      double origin[3];
      double hitPoint[3];
      double hitPointErr[3];

      bool hitFound = false;

      //CERN and DC modules have intermodule coincidence
      if ( type == 'c' || type == 'd' ) {
          std::vector<icarus::crt::CRTChannelData> chandat = febdat.ChanData();

          //get AuxDet and AuxDetSensitive volumes
          uint32_t adid  = MacToAuxDetID(mac,trigpair.first);
          auto const& adGeo = fGeometryService->AuxDet(adid);
          uint32_t  adsid1 = ChannelToAuxDetSensitiveID(mac,trigpair.first);
          uint32_t  adsid2 = ChannelToAuxDetSensitiveID(mac,trigpair.second);
          auto const& adsGeo1 = adGeo.SensitiveVolume(adsid1);
          auto const& adsGeo2 = adGeo.SensitiveVolume(adsid2);

          double stripPosWorld1[3], stripPosWorld2[3];
          double modPos1[3], modPos2[3], hitLocal[3];
          adsGeo1.LocalToWorld(origin,stripPosWorld1);
          adsGeo2.LocalToWorld(origin,stripPosWorld2);
          adGeo.WorldToLocal(stripPosWorld1,modPos1);
          adGeo.WorldToLocal(stripPosWorld2,modPos2);

          float length = adsGeo1.Length();
          float width = adsGeo1.HalfWidth1()*2;

          if ( type == 'c' ) {     
              uint32_t npixel = length/width;

              for (uint8_t i=0; i<npixel; i++) {
                float testz, testx;
                if (trigpair.first<8) {
                  testz = modPos1[2]-length/2 + (width/2)*i;
                  testx =  modPos2[0]-length/2 + (width/2)*i;
                  if (abs(modPos2[2]-testz) < width/2) {
                    hitLocal[0] = testx;
                    hitLocal[1] = 0;
                    hitLocal[2] = testz;
                    adGeo.LocalToWorld(hitLocal,hitPoint);
                    hitFound = true;
                    break;
                  }//if overlap found
                }
                else {
                  testz = modPos2[2]-length/2 + (width/2)*i;
                  testx = modPos1[0]-length/2 + (width/2)*i;
                  if (abs(modPos1[2]-testz) < width/2) {
                    hitLocal[0] = testx;
                    hitLocal[1] = 0;
                    hitLocal[2] = testz;
                    adGeo.LocalToWorld(hitLocal,hitPoint);
                    hitFound = true;
                    break;
                  }//if overlap found
                }
              }//loop over 'pixels'

              if ( hitFound ) {
                hitPointErr[0] = width/sqrt(12);
                hitPointErr[1] = adGeo.HalfHeight();
                hitPointErr[2] = width/sqrt(12);
              }

          }//if c type

          if ( type == 'd' ) {
             hitPoint[0] = 0.5 * ( stripPosWorld1[0] + stripPosWorld2[0] );
             hitPoint[1] = 0.5 * ( stripPosWorld1[1] + stripPosWorld2[1] );
             hitPoint[2] = 0.5 * ( stripPosWorld1[2] + stripPosWorld2[2] );

             hitPointErr[0] = abs(stripPosWorld1[0] - stripPosWorld2[0])/sqrt(12);
             hitPointErr[1] = adGeo.HalfHeight();
             hitPointErr[2] = length/sqrt(12);
          } // if d type


          if (!hitFound) {
              mf::LogInfo("CRT") << "COULD NOT BUILD HIT!!!" << '\n'
                  << "  AuxDetID: " << adid << '\n'
                  << "  AuxDetSID1 / AuxDetSID2 : " << adsid1 << " / " << adsid2 << '\n'
                  << "  expected from trigPair: " << trigpair.first << " , " << trigpair.second;
                  //<< "  mod" << '\n' ;
              nHitMiss++;
              continue;
          }
          else {

            for(auto chan : chandat) {

              if (chan.Channel() == trigpair.first) {
                t01 = chan.T0();
                t11 = chan.T1();
                //t01corr = t01;
                //t11corr = t11;
              }
              if (chan.Channel() == trigpair.second) {
                t02 = chan.T0();
                t12 = chan.T1();
                //t02corr = t02;
                //t12corr = t12;
              }
              if (t01!=0 && t02!=0) {
                t0 = 0.5 * ( t01 + t02 );
                t1 = 0.5 * ( t11 + t12 );
                t0corr = t0;
                t1corr = t1;
                break;
              }
            }//for ChannelData
          }//if hitFound

      mf::LogInfo("CRT") << " CRT HIT PRODUCED!" << '\n'
                  << "   AuxDetID: " << adid << '\n'
                  << "   AuxDetSID1 / AuxDetSID2 : " << adsid1 << " / " << adsid2 << '\n'
                  << "   x: " << hitPoint[0] << " , y: " << hitPoint[1] << " , z: " << hitPoint[2] << '\n'
                  << "   xerr: " << hitPointErr[0] << " , yerr: " << hitPointErr[1] << " , zerr: " << hitPointErr[2] << '\n'
                  << "   t0: " << t0 << " , t0corr: " << t0corr << " , t1: " << t1 << " , t1corr: " << t1corr << '\n';

      CRTHits->push_back(icarus::crt::CRTHit(hitPoint[0],hitPoint[1],hitPoint[2],  \
                         hitPointErr[0],hitPointErr[1],hitPointErr[2],  \
                         t0, t0corr, t1, t1corr, macPair)); 
      }

      if ( type == 'm' ) {
          for (auto const &febdat2 : (*crtListHandle)) {
              if (febdat.MacPair().second==febdat2.Mac5()) {
                  continue;
              }
          }         
      }

    }//for FEBData

    mf::LogInfo("CRT") << CRTHits->size() << " CRT hits produced!" << '\n'
              << nHitMiss << " CRT hits missed!" << '\n';
    

    event.put(std::move(CRTHits));

  } //produce

  void CRTSimHitProducer::endJob()
  {

  }

  DEFINE_ART_MODULE(CRTSimHitProducer)

} //namespace crt
} //namespace icarus

namespace {
  // Local namespace for local functions

  char MacToType(uint32_t mac) {

      if(mac>=0 && mac<=99) return 'm';
      if(mac>=148 && mac<=161) return 'd';
      if(mac>=162&&mac<=283) return 'c';

      return 'e';
  }

  uint32_t MacToRegion(uint32_t mac){

      if(mac>=162 && mac<=245) return 38; //top
      if(mac>=246 && mac<=258) return 52; //slope left
      if(mac>=259 && mac<=271) return 56; //slope right
      if(mac>=272 && mac<=277) return 48; //slope front
      if(mac>=278 && mac<=283) return 46; //slope back
      if(mac>=0   && mac<=17 ) return 50; //left
      if(mac>=50  && mac<=67 ) return 50; //left
      if(mac>=18  && mac<=35 ) return 54; //right
      if(mac>=68  && mac<=85 ) return 54; //right
      if(mac>=36  && mac<=42 ) return 44; //front
      if(mac>=86  && mac<=92 ) return 44; //front
      if(mac>=43  && mac<=49 ) return 42; //back
      if(mac>=93  && mac<=99 ) return 42; //back
      if(mac>=148 && mac<=161) return 58; //bottom

      return 0;
  }

  uint32_t MacToAuxDetID(uint32_t mac, uint32_t chan){
    char type = MacToType(mac);
    if (type == 'e') return UINT16_MAX;
    if (type == 'c' || type == 'd') return mac;
    if (type == 'm') {
      if (chan>=0  && chan<=9 ) return (mac/3)*3;
      if (chan>=10 && chan<=19) return (mac/3)*3 + 1;
      if (chan>=20 && chan<=29) return (mac/3)*3 + 2;
    }

    return UINT16_MAX;
  }

  uint32_t ChannelToAuxDetSensitiveID(uint32_t mac, uint32_t chan) {
    char type = MacToType(mac);
    if (type=='e') return UINT8_MAX;
    if (type=='d') return chan;
    if (type=='c') return chan/2;
    if (type=='m') return (chan % 10)*2;

      return UINT8_MAX;
  }

} //namespace local
